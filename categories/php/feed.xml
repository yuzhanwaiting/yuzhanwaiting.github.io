<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>微端生活</title>
    <link>http://www.yuzhan.me/categories/php/feed/index.xml</link>
    <description>Recent content on 微端生活</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <atom:link href="http://www.yuzhan.me/categories/php/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>依赖注入和控制反转</title>
      <link>http://www.yuzhan.me/post/2015-08-14-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</link>
      <pubDate>Fri, 14 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://www.yuzhan.me/post/2015-08-14-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</guid>
      <description>

&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;

&lt;h3 id=&#34;依赖注入-dependency-injection-di&#34;&gt;依赖注入(&lt;code&gt;Dependency Injection,DI&lt;/code&gt;)&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;高层类应该依赖底层基础设施来提供必要的服务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;控制反转-inversion-ofcontrol-ioc&#34;&gt;控制反转(&lt;code&gt;Inversion ofControl,IoC&lt;/code&gt;)&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;

&lt;h3 id=&#34;依赖注入&#34;&gt;依赖注入&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;先假设一个类&lt;code&gt;Foo&lt;/code&gt;中一个属性，依赖一个对象的实例&lt;code&gt;Bar&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
class Foo
{
   private $_bar;
   public function __construct() {
     $this-&amp;gt;_bar = new Bar();
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;new Bar()&lt;/code&gt;,将对象的实例赋值给成员属性&lt;code&gt;$bar&lt;/code&gt;解决了问题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然而，当我们的需求变的复杂，对于不同的参数，或者当&lt;code&gt;Bar&lt;/code&gt;类有多种驱动实现如何处理。结合工厂模式，我们很快想到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
class Foo
{
   private $_bar;
   public function __construct($driver,$params) {
     $this-&amp;gt;_bar = BarFactory::getInstance($driver,$params);
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;工厂函数&lt;code&gt;BarFactory::getInstacne()&lt;/code&gt;,包含两个参数，&lt;code&gt;$driver&lt;/code&gt;和&lt;code&gt;$params&lt;/code&gt;。&lt;code&gt;$driver&lt;/code&gt;表示&lt;code&gt;Bar&lt;/code&gt;所使用的驱动，而&lt;code&gt;$params&lt;/code&gt;则表示参数。借此，我们可以满足需求的变动。之后新增新的驱动，也能很好的添加&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;事情貌似很完美了。可是，我们仔细想想会发现，如果注入类的类多了，或者，&lt;code&gt;BarFactory&lt;/code&gt;变动了。我们就得相应的修改&lt;code&gt;Foo&lt;/code&gt;的&lt;code&gt;__construct&lt;/code&gt;。那么我们怎么解决这类问题呢。此时，我们引入依赖注入(&lt;code&gt;Dependency Injection&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
class Foo
{
   private $_bar;
   public function __construct($bar) {
     $this-&amp;gt;_bar = $bar;
   }
}
$bar = BarFactory::getInstance($driver,$params);
$foo = new Foo($bar);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一来，Foo类与Bar类解除耦合了。Foo类中已经完全没有工厂方法或者Bar类的身影。我们通过外部实例化&lt;code&gt;Bar&lt;/code&gt;类，然后传入&lt;code&gt;Foo&lt;/code&gt;构建新的&lt;code&gt;Foo&lt;/code&gt;实例。
这就叫&lt;strong&gt;依赖注入&lt;/strong&gt;，实现不是在代码内部创建依赖关系，而是让其作为一个参数传递，这使得我们的程序更容易维护，降低程序代码的耦合度，实现一种松耦合。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;控制反转&#34;&gt;控制反转&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;接上面的类，我们解决了耦合的问题。但是随着一个类越来越复杂，依赖的类变多，如何解决这个问题呢。&lt;br /&gt;
我们可以传入多个类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
class Foo
{
   private $_bar;
   private $_pin;
       
   public function __construct($bar,$pin) {
     $this-&amp;gt;_bar = $bar;
     $this-&amp;gt;_pin = $pin;
   }
}
$bar = BarFactory::getInstance($driver,$params);
$pin = PinFactory::getInstance($pin);
$foo = new Foo($bar,$pin);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果有更多的类的一来，那么&lt;code&gt;construct&lt;/code&gt;的参数列表将会很长。我们维护将变得十分困难。那么我们如何处理这个问题呢。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们想，如果有个容器能够专门管理这些类，需要调用的时候取出来就行了。这里我们提出一个概念&lt;strong&gt;容器&lt;/strong&gt;，又叫做&lt;strong&gt;IoC容器&lt;/strong&gt;、&lt;strong&gt;DI容器&lt;/strong&gt;。
先看看如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
class Foo
{
   private $_di;
   public function __construct(Di $di) {
     $this-&amp;gt;_di = $di;
   }
       
   public function userBar(){
     $this-&amp;gt;_di-&amp;gt;get(&#39;bar&#39;)-&amp;gt;doSomething();
   }
       
   public function userPin(){
     $this-&amp;gt;_di-&amp;gt;get(&#39;pin&#39;)-&amp;gt;doSomething();
   }
}
$di = new Di();
    
$di-&amp;gt;set(&#39;bar&#39;,BarFactory::getInstance($driver,$params));
$di-&amp;gt;set(&#39;pin&#39;,PinFactory::getInstance($pin));
    
$foo = new Foo($di);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，我们通过&lt;code&gt;$di&lt;/code&gt;将可能会遇到各类实例注入到容器中。通过&lt;code&gt;$di-&amp;gt;set&lt;/code&gt;方法将需要的实例注册到容器。之后我们只用在需要的位置调用&lt;code&gt;$di-&amp;gt;get&lt;/code&gt;就能得到各类实例了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;问题来了，网站的项目十分庞大，将这么多类注入到容器中，消耗过多内存怎么办。经过思考，我们可以把重要的类的实例放入容器。对于部分只在调用时才需要的容器，可以借助PHP的回调函数解决。代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$di = new Di();
    
$di-&amp;gt;set(&#39;bar&#39;,function(){
  return new Bar();
});
$di-&amp;gt;set(&#39;pin&#39;,function(){
  return new Pin();
});
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一切似乎很完美。等等，如果很多重要的类放入容器，依然会消耗一部分内存。此时，我们可以直接传入类名，然后等到使用的时候实例化。代码实现如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$di = new Di();
$di-&amp;gt;set(&#39;bar&#39;,&#39;\Application\Lib\Bar&#39;);
$di-&amp;gt;set(&#39;pin&#39;,&#39;\Application\Lib\Pin&#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果类的命名空间很长，那么可以设置一些别名，来简化导入。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//假设存在一个别名处理类DiAlias，已经注入到容器di中。
//并且，这个别名处理存在一个方法setAlias，将别名与类做映射
$di-&amp;gt;get(&#39;DiAlias&#39;)-&amp;gt;setAlias(&#39;\Application\Lib\Bar&#39;,&#39;Bar&#39;);
//如果有多个别名，我们可以定义一些另外的方法。
$alias = [
    &amp;quot;Bar&amp;quot; =&amp;gt; &amp;quot;\Application\Lib\Bar&amp;quot;,
    &amp;quot;Pin&amp;quot; =&amp;gt; &amp;quot;\Application\Lib\Pin&amp;quot;,
];
//此时可以读取这个配置
$di-&amp;gt;get(&#39;DiAlias&#39;)-&amp;gt;setAllAlias($alias);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;说了这么多&lt;code&gt;di&lt;/code&gt;容器，那么到底&lt;code&gt;di&lt;/code&gt;容器的&lt;code&gt;set&lt;/code&gt;和&lt;code&gt;get&lt;/code&gt;是怎样实现的呢。下面给出简单的实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
class Di
{
   private $_ins;
       
   public function set($name,$instance)
    {
       //设置实例
       $this-&amp;gt;_ins[$name] = $instance;
    }
        
    public function get($name)
    {
       //判断实例是否存在
       if (!isset($this-&amp;gt;_ins[$name])) {
           throw new Exception(&amp;quot;instance not found&amp;quot;);
       }
           
       $instance = $this-&amp;gt;_ins[$name];
       //如果为闭包，则直接调用闭包函数
       if ($instance instanceof Closure) {
           return call_user_func($instance);
       } else {
           return new $instance();
       }
    }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接下来，需求更复杂了。如果我们使用的&lt;code&gt;Bar&lt;/code&gt;类依赖另外一个类&lt;code&gt;Page&lt;/code&gt;的实现。上面的方法如何解决。类似如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
class Bar
{
    public function __construct(Page $page) {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过思考，我们想到了PHP的发射。通过反射机制来获取依赖关系&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
class Di
{
    private $_ins;
    
   public function set($name, $instance)
   {
       //设置实例
       $this-&amp;gt;_ins[$name] = $instance;
   }
       
   public function get($name)
   {
       //判断实例是否存在
       if (!isset($this-&amp;gt;_ins[$name])) {
           throw new Exception(&amp;quot;instance not found&amp;quot;);
       }
    
       $instance = $this-&amp;gt;_ins[$name];
       //如果为闭包，则直接调用闭包函数
       if ($instance instanceof Closure) {
           return call_user_func($instance);
       } else {
           //如果不为闭包，直接建立依赖关系实例化
           $object = $this-&amp;gt;build($instance);
           return $object;
       }
   }
    
    //建立依赖关系
    protected function build($instance)
    {
        //获取依赖关系
        list ($reflection, $dependencies) = $this-&amp;gt;getDependencies($instance);
    
        //如果依赖不为空,根据参数实例化
        if (!empty($dependencies)) {
            return $reflection-&amp;gt;newInstanceArgs($dependencies);
        } else {
            //如果依赖不为空，则直接实例化参数
            $object = $reflection-&amp;gt;newInstanceArgs();
            return $object;
        }
    }
    
    //获取实例的依赖关系，方便实例化类
    protected function getDependencies($instance)
    {
        $dependencies = [];
//        实例化反射类
        $reflection = new ReflectionClass($instance);
    
//        获取初始化函数，用于检测是否包含依赖注入
        $constructor = $reflection-&amp;gt;getConstructor();
    
        if ($constructor !== null) {
//            获取初始化函数类名，判断是否存在依赖关系
            foreach ($constructor-&amp;gt;getParameters() as $param) {
                $c = $param-&amp;gt;getClass();
                $dependencies[] = $c-&amp;gt;getName();
            }
        }
        return array($reflection,$dependencies);
    }
    
    //解决依赖关系
    protected function resolveDependencies($dependencies)
    {
        foreach ($dependencies as $index =&amp;gt; $dependency) {
            $dependencies[$index] = $this-&amp;gt;get($dependency);
        }
        return $dependencies;
    }
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;虽然还有些地方没有完善。例如类的参数如何处理，添加依赖注入的时候，能够添加新的别名。添加依赖注入如何添加参数，单例等等。这些都还没细说。这里只是对依赖注入和&lt;code&gt;IoC&lt;/code&gt;容器做一个大概说明。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;现在的框架，不搞个&lt;code&gt;DI&lt;/code&gt;，仿佛就落伍了。当然，这自然有许多好处，比如类更加容易调用和控制。类与类之间也是松耦合的。全局大部分东西可以拆开重新替换。确实方便了很多。至于缺点，使用反射机制对性能造成一定的影响。代码对于初学者来说，理解难度过大等。总之，任何东西，适合自己的项目才是最好的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>composer使用教程</title>
      <link>http://www.yuzhan.me/post/2015-08-13-composer%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</link>
      <pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://www.yuzhan.me/post/2015-08-13-composer%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</guid>
      <description>

&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;

&lt;p&gt;对于现代语言而言，包管理器基本上是标配。Java有Maven，Python有pip，Ruby有gem，Nodejs有npm。PHP的则是&lt;a href=&#34;http://pear.php.net/&#34;&gt;PEAR&lt;/a&gt;，不过PEAR坑不少
。
现在，我们有了&lt;a href=&#34;http://getcomposer.org/&#34;&gt;composer&lt;/a&gt;,PHP依赖管理的利器&lt;/p&gt;

&lt;h1 id=&#34;安装composer&#34;&gt;安装Composer&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;$ curl -sS https://getcomposer.org/installer | php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Windows下直接下载安装文件&lt;a href=&#34;https://getcomposer.org/Composer-Setup.exe&#34;&gt;Composer-Setup.exe&lt;/a&gt;安装&lt;/p&gt;

&lt;h1 id=&#34;声明依赖&#34;&gt;声明依赖&lt;/h1&gt;

&lt;p&gt;在项目目录下创建一个&lt;code&gt;composer.json&lt;/code&gt;文件，指明依赖，比如，你的项目依赖 &lt;a href=&#34;https://github.com/Seldaek/monolog&#34;&gt;monolog&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;require&amp;quot;: {
    &amp;quot;monolog/monolog&amp;quot;: &amp;quot;1.2.*&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;安装依赖&#34;&gt;安装依赖&lt;/h1&gt;

&lt;p&gt;安装依赖非常简单，只需在项目目录下运行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;comoposer installer
//如果没有全局安装的话，则运行：
php composer.phar install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;自动加载&#34;&gt;自动加载&lt;/h1&gt;

&lt;p&gt;Composer提供了自动加载的特性，只需在你的代码的初始化部分中加入下面一行：&lt;br /&gt;
&lt;code&gt;require  &#39;vendor/autoload.php&#39;;&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;简要文档&#34;&gt;简要文档&lt;/h1&gt;

&lt;h3 id=&#34;关于-require-key&#34;&gt;关于&lt;code&gt;require&lt;/code&gt;KEY&lt;/h3&gt;

&lt;p&gt;第一件事情（并且往往只需要做这一件事），你需要在 &lt;code&gt;composer.json&lt;/code&gt; 文件中指定 &lt;code&gt;require&lt;/code&gt; key 的值。你只需要简单的告诉 Composer 你的项目需要依赖哪些包。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;require&amp;quot;: {
        &amp;quot;monolog/monolog&amp;quot;: &amp;quot;1.0.*&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以看到， &lt;code&gt;require&lt;/code&gt; 需要一个 &lt;strong&gt;包名称&lt;/strong&gt; （例如 &lt;code&gt;monolog/monolog&lt;/code&gt;） 映射到 &lt;strong&gt;包版本&lt;/strong&gt; （例如 &lt;code&gt;1.0.*&lt;/code&gt;） 的对象。&lt;/p&gt;

&lt;h3 id=&#34;包名称&#34;&gt;包名称&lt;/h3&gt;

&lt;p&gt;包名称由供应商名称和其项目名称构成。如&lt;code&gt;monolog/monolog&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;包版本&#34;&gt;包版本&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2015/08/composer_01.png&#34; alt=&#34;包版本&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;下一个重要版本-波浪号运算符&#34;&gt;下一个重要版本（波浪号运算符）&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;~&lt;/code&gt; 最好用例子来解释： &lt;code&gt;~1.2&lt;/code&gt; 相当于 &lt;code&gt;&amp;gt;=1.2,&amp;lt;2.0&lt;/code&gt;，而 &lt;code&gt;~1.2.3&lt;/code&gt; 相当于 &lt;code&gt;&amp;gt;=1.2.3,&amp;lt;1.3&lt;/code&gt;。正如你所看到的这对于遵循 &lt;a href=&#34;http://semver.org/lang/zh-CN/&#34;&gt;语义化版本号&lt;/a&gt; 的项目最有用。&lt;/p&gt;

&lt;h3 id=&#34;稳定性&#34;&gt;稳定性&lt;/h3&gt;

&lt;p&gt;默认情况下只有稳定的发行版才会被考虑在内。如果你也想获得 RC、beta、alpha 或 dev 版本，你可以使用 &lt;a href=&#34;http://docs.phpcomposer.com/04-schema.html#Package-links&#34;&gt;稳定标志&lt;/a&gt;。你可以对所有的包做 &lt;a href=&#34;http://docs.phpcomposer.com/04-schema.html#minimum-stability&#34;&gt;最小稳定性&lt;/a&gt; 设置，而不是每个依赖逐一设置。&lt;/p&gt;

&lt;h3 id=&#34;安装依赖包&#34;&gt;安装依赖包&lt;/h3&gt;

&lt;p&gt;获取定义的依赖到你的本地项目，只需要调用 &lt;code&gt;composer.phar&lt;/code&gt; 运行 &lt;code&gt;install&lt;/code&gt; 命令。&lt;br /&gt;
&lt;code&gt;php composer.phar install&lt;/code&gt;&lt;br /&gt;
接着前面的例子，这将会找到 &lt;code&gt;monolog/monolog&lt;/code&gt; 的最新版本，并将它下载到 &lt;code&gt;vendor&lt;/code&gt; 目录。 这是一个惯例把第三方的代码到一个指定的目录 &lt;code&gt;vendor&lt;/code&gt;。如果是 monolog 将会创建 &lt;code&gt;vendor/monolog/monolog&lt;/code&gt; 目录。
另一件事是 &lt;code&gt;install&lt;/code&gt; 命令将创建一个 &lt;code&gt;composer.lock&lt;/code&gt; 文件到你项目的根目录中。&lt;/p&gt;

&lt;h3 id=&#34;composer-lock-锁文件&#34;&gt;&lt;code&gt;composer.lock&lt;/code&gt; - 锁文件&lt;/h3&gt;

&lt;p&gt;在安装依赖后，Composer 将把安装时确切的版本号列表写入 &lt;code&gt;composer.lock&lt;/code&gt; 文件。这将锁定改项目的特定版本。&lt;br /&gt;
如果你的依赖更新了新的版本，你将不会获得任何更新。此时要更新你的依赖版本请使用 &lt;code&gt;update&lt;/code&gt; 命令。这将获取最新匹配的版本（根据你的 &lt;code&gt;composer.json&lt;/code&gt; 文件）并将新版本更新进锁文件。&lt;br /&gt;
&lt;code&gt;php composer.phar update&lt;/code&gt;&lt;br /&gt;
如果只想安装或更新一个依赖，你可以白名单它们：&lt;br /&gt;
&lt;code&gt;php composer.phar update monolog/monolog [...]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;packagist&#34;&gt;Packagist&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://packagist.org/&#34;&gt;packagist&lt;/a&gt; 是 Composer 的主要资源库。 一个 Composer 的库基本上是一个包的源：记录了可以得到包的地方。Packagist 的目标是成为大家使用库资源的中央存储平台。这意味着你可以 &lt;code&gt;require&lt;/code&gt; 那里的任何包。&lt;/p&gt;

&lt;h3 id=&#34;自动加载-1&#34;&gt;自动加载&lt;/h3&gt;

&lt;p&gt;对于库的自动加载信息，Composer 生成了一个 &lt;code&gt;vendor/autoload.php&lt;/code&gt; 文件。你可以简单的引入这个文件，你会得到一个免费的自动加载支持。&lt;br /&gt;
&lt;code&gt;require &#39;vendor/autoload.php&#39;;&lt;/code&gt;&lt;br /&gt;
这使得你可以很容易的使用第三方代码。例如：如果你的项目依赖 monolog，你就可以像这样开始使用这个类库，并且他们将被自动加载。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$log = new Monolog\Logger(&#39;name&#39;);
$log-&amp;gt;pushHandler(new Monolog\Handler\StreamHandler(&#39;app.log&#39;, Monolog\Logger::WARNING));

$log-&amp;gt;addWarning(&#39;Foo&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;详细文档&#34;&gt;详细文档&lt;/h3&gt;

&lt;p&gt;更多详细文档,&lt;a href=&#34;http://docs.phpcomposer.com/&#34;&gt;请查看&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;常用第三方库&#34;&gt;常用第三方库&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;日志管理：&lt;code&gt;monolog/monolog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;时间管理：&lt;code&gt;nesbot/carbon&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ORM: &lt;code&gt;doctrine/orm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;图片处理：&lt;code&gt;intervention/image&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;HTTP处理: &lt;code&gt;guzzle/guzzle&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;缓存处理：&lt;code&gt;doctrine/cache&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据库管理：&lt;code&gt;robmorgan/phinx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文件处理系统： &lt;code&gt;symfony/filesystem&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>php设定多维数组的值</title>
      <link>http://www.yuzhan.me/post/2014-03-27-php%E8%AE%BE%E5%AE%9A%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC/</link>
      <pubDate>Thu, 27 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://www.yuzhan.me/post/2014-03-27-php%E8%AE%BE%E5%AE%9A%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC/</guid>
      <description>&lt;p&gt;今天同事问了我一个问题，我思前想后，将其改变了一下，于是就有了下面这题：&lt;/p&gt;

&lt;p&gt;假设一个数组如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$array = array(
    &#39;a&#39; =&amp;gt;array(
        &#39;b&#39; =&amp;gt; array(
            &#39;c&#39; =&amp;gt; array(
                &#39;d&#39; =&amp;gt; array(
                    &#39;e&#39; =&amp;gt; 3
                )
            )
        )
    ),
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假定有个函数可以&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Config::set(&#39;a.b.c.d.e&#39;,6,$array)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如何将其中最内层的&lt;strong&gt;e&lt;/strong&gt;设置为6。可能，我们首先想到的就是递归，然后在设置。当然，这个方法是可行的。加入，我们不断的加层级，那么递归的带来的性能消耗可能就很明显了。&lt;/p&gt;

&lt;p&gt;思来想去就用下面的方法解决&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Config
{
    static function set($path,$value,&amp;amp;$array)
    {
        //分解层级
        $path_arr = explode(&amp;quot;.&amp;quot;,$path);
        $count = count($path_arr);
        if($count == 0) return false;
        $str = &#39;&#39;;
        //循环层级，构建数组形式
        for($i=0;$i&amp;amp;lt;$count;$i++)
        {   
            if($i == 0)
            {
                $str .= &#39;$array[\&#39;&#39;.$path_arr[$i].&#39;\&#39;]&#39;;
            }
            else
                $str .= &#39;[\&#39;&#39;.$path_arr[$i].&#39;\&#39;]&#39;;
        }
        //设定值
        eval(&amp;quot;$str = $value;&amp;quot;); 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此代码中最重要的就是&lt;strong&gt;$str&lt;/strong&gt;构造数组形式，最后通过eval设定值。整个过程没有用到递归，程序也很好理解。&lt;/p&gt;

&lt;p&gt;我们发现，其实很多时候，稍微想想，还是能给出更好的解决方法的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无限级分类研究：（八）新的方法</title>
      <link>http://www.yuzhan.me/post/2014-02-16-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E5%85%AB%EF%BC%89%E6%96%B0%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 16 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>http://www.yuzhan.me/post/2014-02-16-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E5%85%AB%EF%BC%89%E6%96%B0%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;p&gt;我们之前介绍第二种方法，用栏目的path来定义结构，最后达到一条语句输出的结果。如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/01/一条sql输出所有栏目1.png&#34; alt=&#34;一条sql输出所有栏目&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过这个结构，我们不难想象，这个结构的关键就在于path。但我们仔细看表的时候，发觉path和pid之间有些多余，有没有一种方法，更够简化呢，答案当然是有的。&lt;/p&gt;

&lt;p&gt;上图，我们发现new_order是path和id的结合。于是可以思索，如果此结构本来就存在，我们如何做？&lt;/p&gt;

&lt;p&gt;要解释这个问题，我们先给出表结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE `category` (
  `struct` varchar(30) NOT NULL COMMENT &#39;栏目结构&#39;,
  `name` varchar(30) NOT NULL COMMENT &#39;栏目名称&#39;
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个表已经简化成只有两个字段了。我们思索了一下，如果一直用连接符&amp;#8221;-&amp;#8221;来连接，那么是不是显得很不好看。&lt;br /&gt;
于是我们索性把它去掉，下面，我们看看表中的数据&lt;br /&gt;
&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/02/新无限极分类.png&#34; alt=&#34;新无限极分类&#34; /&gt;&lt;br /&gt;
看结构，我们知道，栏目是以&lt;strong&gt;01&lt;/strong&gt;开始，如果是他的子栏目，则变成&lt;strong&gt;0101&lt;/strong&gt;，而0101的兄弟栏目则是&lt;strong&gt;0102&lt;/strong&gt;，我们执行下一段sql&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SELECT * FROM category ORDER BY struct&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;得到下图，我们更能够清楚的看清结构&lt;br /&gt;
&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/02/新结构层次图.png&#34; alt=&#34;新结构层次图&#34; /&gt;&lt;br /&gt;
既然结构出来了，我们就应该想想该如何增删改。&lt;/p&gt;

&lt;p&gt;之前的程序，我们添加的时候，没有去思考，栏目的id是多少，因为是自动递增的。我们只需要考虑它的的父级栏目就可以，而父级栏目也是很好确定的。&lt;/p&gt;

&lt;p&gt;看这里，我们不仅要确定父级栏目，还要确定自己的编号。&lt;/p&gt;

&lt;p&gt;经过我们观察，父级栏目的&lt;strong&gt;struct,&lt;/strong&gt;就是自己&lt;strong&gt;struct&lt;/strong&gt;去掉最后两位。比如，新闻的&lt;strong&gt;struct&lt;/strong&gt;为&lt;strong&gt;01&lt;/strong&gt;，他的子栏目体育新闻的&lt;strong&gt;struct&lt;/strong&gt;为&lt;strong&gt;0101&lt;/strong&gt;。同样，困扰我们的是，自己的编号怎么确定。&lt;/p&gt;

&lt;p&gt;我们知道，struct必须为唯一，那么，那么子栏目，必须为01 &amp;#8211; 99，不能相同。&lt;/p&gt;

&lt;p&gt;为了能让，栏目能够更好的利用，我们将下一个增加的子栏目定位，最后一个兄弟栏目的编号+1&lt;/p&gt;

&lt;p&gt;这么说，如果我们要在世界下面加个子栏目，由于最后一个子栏目编号为&lt;strong&gt;0202,&lt;/strong&gt;也就是欧洲，于是我们新加的栏目编号为&lt;strong&gt;0203&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;于是，添加栏目所有的问题就在于怎样获得栏目编号，下面给出程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private function getLastStruct($pstruct=null)
{

    //没有父级栏目，也就是为顶级栏目
    if(!$pstruct)
        $sql = &amp;quot;select * from category where length(struct)=2 order by struct desc limit 1&amp;quot;;
    else
        $sql = &#39;select * from category where (length(struct) - length(&amp;quot;&#39;.$pstruct.&#39;&amp;quot;) = 2) AND (struct like &amp;quot;&#39;.$pstruct.&#39;%&amp;quot;) order by struct desc limit 1&#39;;

    $result = $this-&amp;gt;db-&amp;gt;query($sql);
    $row = $result-&amp;gt;fetch_assoc();
    //没有父级栏目，没有任何结果，表示为初始栏目
    if(!$row)
        $struct = $pstruct.&amp;quot;01&amp;quot;;
    else
    {
        $len = strlen($row[&#39;struct&#39;]);
        $struct = sprintf(&amp;quot;%0&amp;quot;.$len.&amp;quot;d&amp;quot;,$row[&#39;struct&#39;] + 1);
    }
    return $struct;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面给出添加函数，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function add($pstruct,$name)
{
    //获取新的struct
    $data[&#39;struct&#39;] = $this-&amp;gt;getLastStruct($pstruct);
    $data[&#39;name&#39;] = $name;

    $sql = &amp;quot;insert into category (struct,name) values(&#39;&amp;quot;.$data[&#39;struct&#39;].&amp;quot;&#39;,&#39;&amp;quot;.$data[&#39;name&#39;].&amp;quot;&#39;)&amp;quot;;
    $this-&amp;gt;db-&amp;gt;query($sql);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加就写完了，明天继续给大家分享，删除和修改&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无限级分类研究：（七）栏目的排序</title>
      <link>http://www.yuzhan.me/post/2014-01-17-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E4%B8%83%EF%BC%89%E6%A0%8F%E7%9B%AE%E7%9A%84%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 17 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://www.yuzhan.me/post/2014-01-17-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E4%B8%83%EF%BC%89%E6%A0%8F%E7%9B%AE%E7%9A%84%E6%8E%92%E5%BA%8F/</guid>
      <description>&lt;p&gt;昨天我们的程序完成之后，发觉，我们栏目完全无法按照list_order来排序。实际情况中，除非对排序要求不是很高的栏目，比如地区，职业行业等等信息，其他的如，商品栏目之类，都是需要排序。&lt;/p&gt;

&lt;p&gt;因此，我们不能不能不去思考这个问题。当我们思考起这个问题时，有发觉难以下手。&lt;/p&gt;

&lt;p&gt;那我们应该整理一下思路，&lt;/p&gt;

&lt;p&gt;我们排序的规则如下: 父栏目 &amp;#8212;-&amp;gt; 子栏目&lt;/p&gt;

&lt;p&gt;也就是说，父栏目排完，再把子栏目插入父栏目之中。我们似乎又得做循环插入的事情。如果用到递归，那么，我们这个程序似乎就不是那么完美。那有没有别的方法呢？&lt;/p&gt;

&lt;p&gt;答案是有的。我们的思路是先组合一组栏目，再组合另一组，最后对每个组合进行排序，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/01/新排序方式思维图.jpg&#34; alt=&#34;新排序方式思维图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;下面就加入我们的程序，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 排序
 */
function listorder()
{
    $array = array();
    foreach($this-&amp;gt;data as $key =&amp;gt; $val)
    {
        // 查找该栏目的层级
        $array = explode(&amp;quot;-&amp;quot;,$val[&#39;new_order&#39;]);
        // 去除第一个栏目，因为最高级均为0，没有比较的意义
        array_shift($array);
        $order_arr = array();
        foreach($array as $k =&amp;gt; $v)
        {
            //组装新排序，sprintf格式化数据
            $order_arr[] = sprintf(&amp;quot;%03d&amp;quot;,$this-&amp;gt;data[$v][&#39;list_order&#39;]);
        }
        //插入原有数据，方便之后的排序
        $this-&amp;gt;data[$key][&#39;order&#39;] = implode(&amp;quot;-&amp;quot;,$order_arr);
    }
    
    //根据新的order对数组排序，如果大家的php版本低于5.3,请不要使用匿名函数
    uasort($this-&amp;gt;data,function($a,$b){
        if($a[&#39;order&#39;] == $b[&#39;order&#39;]) return 0;
        return $a[&#39;order&#39;] &amp;gt; $b[&#39;order&#39;] ? 1 : -1;
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上程序就是排序。&lt;br /&gt;
可以看出，我们这类方法，适合于输出。但是，对于排序以及修改和删除，比较麻烦。&lt;br /&gt;
这个方法在此告一段落。&lt;/p&gt;

&lt;p&gt;当然，我们的无限级分类还没结束，接下来，我们将有更精彩的讲解，请大家多多关注。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无限级分类研究：（六）栏目添加与修改</title>
      <link>http://www.yuzhan.me/post/2014-01-14-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E5%85%AD%EF%BC%89%E6%A0%8F%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%B8%8E%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Tue, 14 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://www.yuzhan.me/post/2014-01-14-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E5%85%AD%EF%BC%89%E6%A0%8F%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%B8%8E%E4%BF%AE%E6%94%B9/</guid>
      <description>&lt;p&gt;接着昨天的文章讲。&lt;/p&gt;

&lt;p&gt;如何添加栏目，关键点在于，path。这个path如何定义。我们仔细一想，会发现，就是父栏目的path和id的组合。&lt;/p&gt;

&lt;p&gt;因此，我们添加栏目的时候，只用找出父栏目的id就可以了&lt;/p&gt;

&lt;p&gt;下面是程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;header(&amp;quot;Content-type:text/html;charset=utf-8&amp;quot;);
class category_2
{
    protected $db,$data=array(),$order_data=array();

    function __construct()
    {
        $this-&amp;gt;db = new mysqli(&amp;quot;localhost&amp;quot;,&amp;quot;****&amp;quot;,&amp;quot;*****&amp;quot;,&amp;quot;fenlei&amp;quot;);
        $this-&amp;gt;data();
    }

    /**
     * 此函数只用于演示，数据过滤以及验证，请大家自行处理
     */
    function add()
    {
        //测试数据
        // $_POST = array(&amp;quot;pid&amp;quot;=&amp;gt;10,&amp;quot;name&amp;quot;=&amp;gt;&amp;quot;武汉新闻&amp;quot;,&amp;quot;list_order&amp;quot;=&amp;gt;0);

        $pid = $_POST[&#39;pid&#39;];
        $name = $_POST[&#39;name&#39;];
        $list_order = $_POST[&#39;list_order&#39;];

        // 查询父栏目path
        $sql = &amp;quot;select path from category_2 where `id`=&amp;quot;.$pid.&amp;quot; limit 1&amp;quot;;

        $result = $this-&amp;gt;db-&amp;gt;query($sql);
        $row = $result-&amp;gt;fetch_assoc();

        // 构建新的path
        $path = $row[&#39;path&#39;].&amp;quot;-&amp;quot;.$pid;

        // 插入数据
        $sql = &amp;quot;insert into category_2 (`pid`,`name`,`list_order`,`path`) values (&#39;{$pid}&#39;,&#39;{$name}&#39;,&#39;{$list_order}&#39;,&#39;{$path}&#39;)&amp;quot;;
        $this-&amp;gt;db-&amp;gt;query($sql);
    }

    /**
     * 获取数组
     * @return void
     */
    function data()
    {
        $sql = &amp;quot;select *,concat(`path`,&#39;-&#39;,`id`) as new_order from category_2 order by new_order&amp;quot;;
        $res = $this-&amp;gt;db-&amp;gt;query($sql);
        while($row = $res-&amp;gt;fetch_assoc())
            $this-&amp;gt;data[$row[&#39;id&#39;]] = $row;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们只用构建一个表单，就可以添加（请读者自行根据之前的程序，写出表单，如果实在需要，到时候会整理一起发）。&lt;/p&gt;

&lt;p&gt;关于修改，这里我们也会顺带说说删除。&lt;/p&gt;

&lt;p&gt;我们知道每一个栏目的path和父栏目的path结合紧密。因此，当栏目修改父栏目时，考虑的不仅仅是当前栏目，还得考虑他的后代栏目。对于当前栏目的修改，可以说还不算麻烦，但对于后代栏目，我们该如何修改呢？&lt;/p&gt;

&lt;p&gt;我们先看看一下程序。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function edit()
    {
        //测试数据
        // $_POST = array(&#39;id&#39;=&amp;gt;2,&#39;pid&#39;=&amp;gt;8);
         //栏目id
        $id = $_POST[&#39;id&#39;];
        //更新后的父栏目id
        $pid = $_POST[&#39;pid&#39;];

        //获取栏目原父id和path
        $sql = &amp;quot;select pid,path from category_2 where `id`=&amp;quot;.$id.&amp;quot; limit 1&amp;quot;;
        $result = $this-&amp;gt;db-&amp;gt;query($sql);
        $row = $result-&amp;gt;fetch_assoc();
        $old_pid = $row[&#39;pid&#39;];
        $ori_path = $row[&#39;path&#39;];
        $old_path = $ori_path.&amp;quot;-&amp;quot;.$id;

        // 获取新父栏目path
        $sql = &amp;quot;select path from category_2 where `id`=&amp;quot;.$pid.&amp;quot; limit 1&amp;quot;;
        $result = $this-&amp;gt;db-&amp;gt;query($sql);
        $row = $result-&amp;gt;fetch_assoc();
        $new_path = $row[&#39;path&#39;].&amp;quot;-&amp;quot;.$pid;

        // 更新该栏目
$sql = &amp;quot;update category_2 set `path`=&#39;{$new_path}&#39;,`pid`=&#39;{$pid}&#39; where `id`=&#39;{$id}&#39;&amp;quot;;
$this-&amp;gt;db-&amp;gt;query($sql);
        //

        // 更新后代栏目
        $sql = &amp;quot;select `id`,`pid`,`name`,`path`,concat(`path`,&#39;-&#39;,`id`) new_order from category_2 where `path` like &#39;{$old_path}%&#39;&amp;quot;;
        //获取所有后代元素
        $result = $this-&amp;gt;db-&amp;gt;query($sql);
        $data = array();
        while($row = $result-&amp;gt;fetch_assoc())
        {
            // 更新后代元素path
            $descend_path = str_replace($ori_path, $new_path, $row[&#39;path&#39;]);
            $sql = &amp;quot;update category_2 set `path`=&#39;{$descend_path}&#39; where `id`=&amp;quot;.$row[&#39;id&#39;];
            $this-&amp;gt;db-&amp;gt;query($sql);
        }
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们将体育新闻放到欧洲栏目之下，执行之后，我们输出可以得到如下结果&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/01/无限级分类移动父级栏目1.png&#34; alt=&#34;无限级分类移动父级栏目&#34; /&gt;&lt;/p&gt;

&lt;p&gt;经过这么多步骤，我们终于完成了移动栏目。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对比之前的程序，我们发现，该结构最大的有点是效率，但得到效率的同时，我们却花却大量的程序去更新数据。&lt;/strong&gt;&lt;strong&gt;也就是说，用写的效率换取读的效率&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以，当我写程序的时候，需要针对项目，来做取舍。&lt;/p&gt;

&lt;p&gt;那么这个方法完结了么？哈哈，我想跟大家说，这种方法还没完结，如果你已经发现我“漏掉”了什么，那么我下篇文章将好好跟大家说说！&lt;/p&gt;

&lt;p&gt;尽请期待！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无限级分类研究：（五）第二种实现初探</title>
      <link>http://www.yuzhan.me/post/2014-01-13-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E4%BA%94%EF%BC%89%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Mon, 13 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://www.yuzhan.me/post/2014-01-13-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E4%BA%94%EF%BC%89%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%88%9D%E6%8E%A2/</guid>
      <description>&lt;p&gt;继续我们上一篇文章的问题吧。&lt;br /&gt;
我们能不能不用循环就写出某个栏目的子类呢？答案是肯定的。&lt;/p&gt;

&lt;p&gt;要解答这个问题，我们先讨论一个问题。&lt;br /&gt;
之前的程序中，我们给每一个栏目定一个level。如此做，栏目的层级自然分开，十分容易就可以排序。&lt;/p&gt;

&lt;p&gt;既然如此，我们可以考虑构建一个栏目层级。但是这个层级，不能简简单单的定位level，因为level可以很简单的循环出来。我们需要的是一个能够生成无限级的结构。于是，我们可以考虑一下以连接符&amp;#8221;&lt;strong&gt;-&amp;#8221;&lt;/strong&gt;来生成层级。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/01/无限级分类结构示意图1.png&#34; alt=&#34;无限级分类结构示意图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如图，path为层级结构，这种结构的特点，为父栏目的层级。比如新闻的父栏目为0,则path为0，体育新闻的父栏目为1，则path为0-1，以此类推。&lt;/p&gt;

&lt;p&gt;我们以此构建一张表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE `category_2` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;分类id&#39;,
  `pid` int(10) unsigned NOT NULL COMMENT &#39;分类父id&#39;,
  `name` varchar(30) NOT NULL COMMENT &#39;分类名称&#39;,
  `list_order` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;分类排序，默认为0&#39;,
  `path` varchar(255) NOT NULL COMMENT &#39;分级层次&#39;,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，插入数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO `category_2` VALUES (&#39;1&#39;, &#39;0&#39;, &#39;新闻&#39;, &#39;0&#39;, &#39;0&#39;);
INSERT INTO `category_2` VALUES (&#39;2&#39;, &#39;1&#39;, &#39;体育新闻&#39;, &#39;0&#39;, &#39;0-1&#39;);
INSERT INTO `category_2` VALUES (&#39;3&#39;, &#39;1&#39;, &#39;社会新闻&#39;, &#39;3&#39;, &#39;0-1&#39;);
INSERT INTO `category_2` VALUES (&#39;4&#39;, &#39;2&#39;, &#39;NBA&#39;, &#39;5&#39;, &#39;0-1-2&#39;);
INSERT INTO `category_2` VALUES (&#39;5&#39;, &#39;2&#39;, &#39;欧冠&#39;, &#39;2&#39;, &#39;0-1-2&#39;);
INSERT INTO `category_2` VALUES (&#39;6&#39;, &#39;0&#39;, &#39;世界&#39;, &#39;4&#39;, &#39;0&#39;);
INSERT INTO `category_2` VALUES (&#39;7&#39;, &#39;6&#39;, &#39;中东&#39;, &#39;0&#39;, &#39;0-6&#39;);
INSERT INTO `category_2` VALUES (&#39;8&#39;, &#39;6&#39;, &#39;欧洲&#39;, &#39;6&#39;, &#39;0-6&#39;);
INSERT INTO `category_2` VALUES (&#39;9&#39;, &#39;8&#39;, &#39;俄罗斯&#39;, &#39;0&#39;, &#39;0-6-8&#39;);
INSERT INTO `category_2` VALUES (&#39;10&#39;, &#39;3&#39;, &#39;大楚新闻&#39;, &#39;0&#39;, &#39;0-1-3&#39;);
INSERT INTO `category_2` VALUES (&#39;11&#39;, &#39;5&#39;, &#39;皇马&#39;, &#39;0&#39;, &#39;0-1-2-5&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为&lt;strong&gt;path&lt;/strong&gt;字段为varchar,而且结构固定，都是以0开始，因此，我们可以对其进行排序。&lt;/p&gt;

&lt;p&gt;于是我们直接组织sql，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;elect *,concat(`path`,&#39;-&#39;,`id`) new_order from category_2 order by new_order
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此段sql，可以完全输出所有栏目。不用递归，不用缓存，十分简洁。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/01/一条sql输出所有栏目1.png&#34; alt=&#34;一条sql输出所有栏目&#34; /&gt;&lt;br /&gt;
那么，如何输出某个栏目的子栏目呢？比如，此刻的需求就是要求出所有新闻的后代栏目。对于sql熟悉的我们，会马上写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select *,concat(`path`,&#39;-&#39;,`id`) new_order from category_2 where `path` like &amp;quot;0-1%&amp;quot; order by new_order
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/01/求出栏目的后代栏目1.png&#34; alt=&#34;求出栏目的后代栏目&#34; /&gt;&lt;br /&gt;
看看，多么简单。&lt;br /&gt;
就这样，已经解决我们之前需要复杂操作的语句。&lt;/p&gt;

&lt;p&gt;今天就写到这里。明天，我们将说说，该结构的增和改，尽情期待。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无限级分类研究：（四）新方法的引子</title>
      <link>http://www.yuzhan.me/post/2014-01-12-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E6%96%B0%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E5%AD%90/</link>
      <pubDate>Sun, 12 Jan 2014 12:24:34 +0000</pubDate>
      
      <guid>http://www.yuzhan.me/post/2014-01-12-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E6%96%B0%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E5%AD%90/</guid>
      <description>&lt;p&gt;在上一篇文章中，我们已经写出了程序。现在我们探讨一个问题。&lt;/p&gt;

&lt;p&gt;现实中，我们的女友（或女神）可能喜欢逛网店，比如，正好要买一件。我们知道，女孩子买衣服可能会比较纠结，可能首先点击的就是女装，那么，不管是女款羽绒服，还是女款连衣裙都会显示。&lt;/p&gt;

&lt;p&gt;同样，在我们列出的栏目中，我们的用户，可能只是想看看新闻。那么所有的新闻都会被列出来。基于这个需求，我们就得考虑一下我们的程序该怎样写。&lt;/p&gt;

&lt;p&gt;当我们仔细回顾我们的程序时，发觉，我们正好写过此程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 获取栏目下所有后代栏目
 * @param  int $id 栏目id
 * @return array
 */
function get_array($id)
{
    static $level = 1;
    $res = $this-&amp;gt;get_child($id,$level);
    if($level == 1)
        $this-&amp;gt;order_data = $res;
    else
        $this-&amp;gt;order_data = insert_array($res,$id,$this-&amp;gt;order_data);
    if (count($res) &amp;gt; 0)
    {
        $level++;
        foreach($res as $key =&amp;gt; $val)
            $this-&amp;gt;get_array($val[&#39;id&#39;]);
        $level--;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一段代码，我们传一个id，正好能完全遍历出下级来。&lt;/p&gt;

&lt;p&gt;但是，我们脑中对于递归的印象，向来是不好的。项目经理可能会告诉我们，能不用递归，就不要用递归。可是，我们之前输出所有栏目不正好用了递归。&lt;/p&gt;

&lt;p&gt;好吧，细心的你已经发现我的“疏漏”了。针对这个疏漏，我们一般是怎样解决的呢？基于，所有分类，及时性要求不是很高。我们会选择直接缓存。每次增删改的时候更新缓存。这样就能保护网站的高效性，而不用每次都去递归。&lt;/p&gt;

&lt;p&gt;那么，为什么我们不单独缓存二级栏目的后代栏目呢？仔细想想，我们发现，这样的做法不合适。我们的网站体积变大之后，栏目可能会随之增多。如果每个二级栏目缓存，以后三级栏目再缓存。那么缓存文件将会变得很多，&lt;strong&gt;而且，更重要的是，每次增删改，都会十分麻烦&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;既然如此，那我们如何解决这个问题？&lt;br /&gt;
首先，我们观察一下数组，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;array (
    6 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;6&#39;,&#39;pid&#39; =&amp;gt; &#39;0&#39;,&#39;name&#39; =&amp;gt; &#39;世界&#39;,&#39;list_order&#39; =&amp;gt; &#39;4&#39;,&#39;level&#39; =&amp;gt; 1,),
    8 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;8&#39;,&#39;pid&#39; =&amp;gt; &#39;6&#39;,&#39;name&#39; =&amp;gt; &#39;欧洲&#39;,&#39;list_order&#39; =&amp;gt; &#39;6&#39;,&#39;level&#39; =&amp;gt; 2,),
    9 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;9&#39;,&#39;pid&#39; =&amp;gt; &#39;8&#39;,&#39;name&#39; =&amp;gt; &#39;俄罗斯&#39;,&#39;list_order&#39; =&amp;gt; &#39;0&#39;,&#39;level&#39; =&amp;gt; 3,),
    7 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;7&#39;,&#39;pid&#39; =&amp;gt; &#39;6&#39;,&#39;name&#39; =&amp;gt; &#39;中东&#39;,&#39;list_order&#39; =&amp;gt; &#39;0&#39;,&#39;level&#39; =&amp;gt; 2,),
    1 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;1&#39;,&#39;pid&#39; =&amp;gt; &#39;0&#39;,&#39;name&#39; =&amp;gt; &#39;新闻&#39;,&#39;list_order&#39; =&amp;gt; &#39;0&#39;,&#39;level&#39; =&amp;gt; 1,),
    3 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;3&#39;,&#39;pid&#39; =&amp;gt; &#39;1&#39;,&#39;name&#39; =&amp;gt; &#39;社会新闻&#39;,&#39;list_order&#39; =&amp;gt; &#39;3&#39;,&#39;level&#39; =&amp;gt; 2,),
    10 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;10&#39;,&#39;pid&#39; =&amp;gt; &#39;3&#39;,&#39;name&#39; =&amp;gt; &#39;大楚新闻&#39;,&#39;list_order&#39; =&amp;gt; &#39;0&#39;,&#39;level&#39; =&amp;gt; 3,),
    2 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;2&#39;,&#39;pid&#39; =&amp;gt; &#39;1&#39;,&#39;name&#39; =&amp;gt; &#39;体育新闻&#39;,&#39;list_order&#39; =&amp;gt; &#39;0&#39;,&#39;level&#39; =&amp;gt; 2,),
    4 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;4&#39;,&#39;pid&#39; =&amp;gt; &#39;2&#39;,&#39;name&#39; =&amp;gt; &#39;NBA&#39;,&#39;list_order&#39; =&amp;gt; &#39;5&#39;,&#39;level&#39; =&amp;gt; 3,),
    5 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;5&#39;,&#39;pid&#39; =&amp;gt; &#39;2&#39;,&#39;name&#39; =&amp;gt; &#39;欧冠&#39;,&#39;list_order&#39; =&amp;gt; &#39;2&#39;,&#39;level&#39; =&amp;gt; 3,),
    11 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;11&#39;,&#39;pid&#39; =&amp;gt; &#39;5&#39;,&#39;name&#39; =&amp;gt; &#39;皇马&#39;,&#39;list_order&#39; =&amp;gt; &#39;0&#39;,&#39;level&#39; =&amp;gt; 4,)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们发现，每一个下级栏目的level都会大于上级栏目。&lt;br /&gt;
举例子来说：&lt;br /&gt;
&lt;strong&gt;欧洲&lt;/strong&gt;的&lt;strong&gt;level&lt;/strong&gt;为&lt;strong&gt;2&lt;/strong&gt;，而&lt;strong&gt;世界&lt;/strong&gt;的&lt;strong&gt;level&lt;/strong&gt;为&lt;strong&gt;1&lt;/strong&gt;&lt;br /&gt;
之后的&lt;strong&gt;俄罗斯&lt;/strong&gt;，&lt;strong&gt;中东&lt;/strong&gt;，也是如此。&lt;/p&gt;

&lt;p&gt;直到&lt;strong&gt;新闻&lt;/strong&gt;的&lt;strong&gt;level&lt;/strong&gt;为&lt;strong&gt;1&lt;/strong&gt;等于，世&lt;strong&gt;世界&lt;/strong&gt;的&lt;strong&gt;level&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由此，我们能够结论，一个栏目下的level必定大于该栏目的level，如果一直往后遍历，那么，知道出现level小于或等于它。这之间的所有栏目都是其子栏目。&lt;br /&gt;
这句话有点绕，没看懂也不要紧，我们画个图，让大家明白&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/01/无限级后代元素示意图.png&#34; alt=&#34;无限级后代元素示意图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在，我们思考一下，程序该怎么写。&lt;/p&gt;

&lt;p&gt;根据示意图，我可以大概的退出。可以从栏目开始的位置循环，直到level小于或等于该栏目的level，则退出循环，正好可以所有数组。&lt;/p&gt;

&lt;p&gt;所以，有了如下程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 获取栏目后代
 * @param  int $id 栏目id
 * @return
 */
function getDescend($id)
{
    $array = array();
    //栏目层级
    $level = $this-&amp;gt;order_data[$id][&#39;level&#39;];

    //此处循环，构造新的数组，使数组从该栏目开始
    foreach($this-&amp;gt;order_data as $key =&amp;gt; $val)
    {
        //由于我们的栏目是经过排序的，所以，只用去除之前不等于该栏目的所有栏目，
        //得到的新栏目则可以用下一步处理
        if ($key != $id)
            unset($this-&amp;gt;order_data[$key]);
        else
            break;
    }

    //处理第一个栏目，也就是剔除我们的栏目，方便循环
    //记住，此处不能用array_shift()，
    //因为，array_shift()会返回由0开始的下标数组，不是我们需要的结构
    //因此，只能用unset
    unset($this-&amp;gt;order_data[$id]);

    foreach($this-&amp;gt;order_data as $key =&amp;gt; $val)
    {
        //此处计算，正好是我们之前的示意图所说明的
        if ($val[&#39;level&#39;] &amp;gt; $level)
            $array[$key] = $val;
        else
            break;
    }
    return $array;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面程序，最终返回&lt;strong&gt;$id&lt;/strong&gt;下的所有后代元素。&lt;br /&gt;
只用两次循环，就完全解决了问题。效率比之前的递归调用，高了不少。&lt;br /&gt;
于是，我们很高兴，很开心。&lt;br /&gt;
但是，我们能不能写出更完美的程序呢？&lt;br /&gt;
答案是有的，下一篇中，我们将会介绍，新的结构，能够完全解决这个问题。&lt;br /&gt;
所以，朋友们，请继续关注吧&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无限级分类研究：（三）分类输出</title>
      <link>http://www.yuzhan.me/post/2014-01-12-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%B1%BB%E8%BE%93%E5%87%BA/</link>
      <pubDate>Sun, 12 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://www.yuzhan.me/post/2014-01-12-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%B1%BB%E8%BE%93%E5%87%BA/</guid>
      <description>&lt;p&gt;昨天，我们已经得到了数组，接下来就是输出了.我们知道，无限级分类，如果知道层级，是很容易得出很规范的格式。&lt;br /&gt;
之前，我们已经通过get_array已经把层级&lt;strong&gt;level&lt;/strong&gt;得到，由此，不难输出。&lt;/p&gt;

&lt;p&gt;下面，给我完成的程序供大家参考。&lt;br /&gt;
由于本次无限级分类难点主要在输出上。至于添加，没什么太大的难点，填好父id，就可以。(如果大家确实需要，届时再补上)。所以，我只写了输出，增删改都没写。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;header(&amp;quot;Content-type:text/html;charset=utf-8&amp;quot;);
class category_1
{
    protected $db,$data=array(),$order_data=array();
    
    function __construct()
    {
        $this-&amp;gt;db = new mysqli(&amp;quot;localhost&amp;quot;,&amp;quot;root&amp;quot;,&amp;quot;root&amp;quot;,&amp;quot;fenlei&amp;quot;);
        $this-&amp;gt;data();

    }

    /**
     * 输出
     */
    function show($id)
    { 
        $this-&amp;gt;get_array($id);
        echo $this-&amp;gt;format();
    }

    /**
     * 格式化数组
     */
    function format()
    {
        // 此时数组已经得到，通过操作level，我们可以获得自定义的样式
        $str = &amp;quot;&amp;quot;;
        $str .= &amp;quot;&amp;amp;lt;select name=&#39;&#39;&amp;gt;&amp;amp;lt;option&amp;gt;请选择&amp;amp;lt;/option&amp;gt;&amp;quot;;
        foreach($this-&amp;gt;order_data as $key =&amp;gt; $val)
        {
            if($val[&#39;level&#39;] == 1)
                $space = &amp;quot;&amp;quot;;
            else
            {
                $space =str_repeat(&amp;quot;│&amp;amp;nbsp;&amp;quot;, ($val[&#39;level&#39;]-1)).&amp;quot;├&amp;quot;;
            }
            $str .= &amp;quot;&amp;amp;lt;option&amp;gt;&amp;quot;.$space.$val[&#39;name&#39;].&amp;quot;&amp;amp;lt;/option&amp;gt;&amp;quot;;
        }
        $str .=&amp;quot;&amp;amp;lt;/select&amp;gt;&amp;quot;;
        return $str;
    }

    /**
     * 获取栏目下所有后代栏目
     * @param  int $id 栏目id
     * @return array 
     */
    function get_array($id)
    {
        static $level = 1;
        $res = $this-&amp;gt;get_child($id,$level);
        if($level == 1)
            $this-&amp;gt;order_data = $res;
        else
            $this-&amp;gt;order_data = insert_array($res,$id,$this-&amp;gt;order_data);
        if (count($res) &amp;gt; 0)
        {
            $level++;
            foreach($res as $key =&amp;gt; $val)
                $this-&amp;gt;get_array($val[&#39;id&#39;]);
            $level--;
        }
    }

    /**
     * 获取对应子栏目
     * @param  int $pid   父id
     * @param  int $level 层级
     * @return array 
     */
    function get_child($pid,$level)
    {
        $res_array = array();
        foreach($this-&amp;gt;data as $key =&amp;gt; $val)
        {
            if ($val[&#39;pid&#39;] == $pid)
            {
                $val[&#39;level&#39;] = $level;
                $res_array[$key] = $val;
            }
        }
        return $res_array;
    }

    /**
     * 获取数组
     * @return void 
     */
    function data()
    {
        $sql = &amp;quot;select * from category_1_copy order by list_order desc&amp;quot;;
        $res = $this-&amp;gt;db-&amp;gt;query($sql);
        while($row = $res-&amp;gt;fetch_assoc())
            $this-&amp;gt;data[$row[&#39;id&#39;]] = $row;
    }
}

//测试
$demo = new category_1();
$data = $demo-&amp;gt;show(0);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你觉得程序过长，网上观看不方便，本站提供一个包下载，&lt;a href=&#34;http://www.yuzhan.me/public/img/images/2014/01/fenlei.zip&#34;&gt;无限级分类程序1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;尽请期待下一篇文章，我们将介绍第二种方式&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无限级分类研究：（二）具体实现</title>
      <link>http://www.yuzhan.me/post/2014-01-10-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 10 Jan 2014 12:24:34 +0000</pubDate>
      
      <guid>http://www.yuzhan.me/post/2014-01-10-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;p&gt;之前的文章已经说明，如何获取自己。按照之前的图片逻辑，我们会选取第一级栏目，于是有以下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
     * 获取栏目下所有后代栏目
     * @param  int $id 栏目id
     * @return array
     */
    function get_array($id)
    {
        //此处get_child我们已经说过，是去除所有子栏目,其中id为栏目id
        $res = $this-&amp;gt;get_child($id);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印以上数组，我们会得到第一层级，如果要得到第二层级，我们得再循环一次，于是有&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function get_array($id)
    {
        $res = $this-&amp;gt;get_child($id);
        //当数组不为空的时候，即是有后代元素
        if (count($res) &amp;gt; 0)
        {
            foreach($res as $key =&amp;gt; $val)
               $data[$key][&#39;son&#39;] = $this-&amp;gt;get_child($val[&#39;id&#39;]);
        }
    }
//由于结果太长，这这里只打印一组结果
/**
    [6] =&amp;gt; Array
        (
            [son_list] =&amp;gt; Array
                (
                    [8] =&amp;gt; Array
                        (
                            [id] =&amp;gt; 8
                            [pid] =&amp;gt; 6
                            [name] =&amp;gt; 欧洲
                            [list_order] =&amp;gt; 6
                        )

                    [7] =&amp;gt; Array
                        (
                            [id] =&amp;gt; 7
                            [pid] =&amp;gt; 6
                            [name] =&amp;gt; 中东
                            [list_order] =&amp;gt; 0
                        )

                )

        )
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;以上结果虽然输出了自后代，带这种模式肯定不是我们需要的，因为无限极不断完善之后，层级越多，数组嵌套层次越多，到时候读取，会极大的影响性能。&lt;/strong&gt;因此，我们加入level来表示栏目的层级。&lt;/p&gt;

&lt;p&gt;在&lt;a title=&#34;无限级分类研究：（一）初步构想&#34; href=&#34;http://www.yuzhan.me/archives/50.html&#34; target=&#34;_blank&#34;&gt; 无限级分类研究：（一）初步构想&lt;/a&gt; 中，我们已经列出了数组模式，考虑到上面所说的，我们给数组，加上层级。&lt;br /&gt;
第一级为level = 1,依次叠加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;array (
    6 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;6&#39;,&#39;pid&#39; =&amp;gt; &#39;0&#39;,&#39;name&#39; =&amp;gt; &#39;世界&#39;,&#39;list_order&#39; =&amp;gt; &#39;4&#39;,&#39;level&#39; =&amp;gt; 1,),
    8 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;8&#39;,&#39;pid&#39; =&amp;gt; &#39;6&#39;,&#39;name&#39; =&amp;gt; &#39;欧洲&#39;,&#39;list_order&#39; =&amp;gt; &#39;6&#39;,&#39;level&#39; =&amp;gt; 2,),
    9 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;9&#39;,&#39;pid&#39; =&amp;gt; &#39;8&#39;,&#39;name&#39; =&amp;gt; &#39;俄罗斯&#39;,&#39;list_order&#39; =&amp;gt; &#39;0&#39;,&#39;level&#39; =&amp;gt; 3,),
    7 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;7&#39;,&#39;pid&#39; =&amp;gt; &#39;6&#39;,&#39;name&#39; =&amp;gt; &#39;中东&#39;,&#39;list_order&#39; =&amp;gt; &#39;0&#39;,&#39;level&#39; =&amp;gt; 2,),
    1 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;1&#39;,&#39;pid&#39; =&amp;gt; &#39;0&#39;,&#39;name&#39; =&amp;gt; &#39;新闻&#39;,&#39;list_order&#39; =&amp;gt; &#39;0&#39;,&#39;level&#39; =&amp;gt; 1,),
    3 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;3&#39;,&#39;pid&#39; =&amp;gt; &#39;1&#39;,&#39;name&#39; =&amp;gt; &#39;社会新闻&#39;,&#39;list_order&#39; =&amp;gt; &#39;3&#39;,&#39;level&#39; =&amp;gt; 2,),
    10 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;10&#39;,&#39;pid&#39; =&amp;gt; &#39;3&#39;,&#39;name&#39; =&amp;gt; &#39;大楚新闻&#39;,&#39;list_order&#39; =&amp;gt; &#39;0&#39;,&#39;level&#39; =&amp;gt; 3,),
    2 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;2&#39;,&#39;pid&#39; =&amp;gt; &#39;1&#39;,&#39;name&#39; =&amp;gt; &#39;体育新闻&#39;,&#39;list_order&#39; =&amp;gt; &#39;0&#39;,&#39;level&#39; =&amp;gt; 2,),
    4 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;4&#39;,&#39;pid&#39; =&amp;gt; &#39;2&#39;,&#39;name&#39; =&amp;gt; &#39;NBA&#39;,&#39;list_order&#39; =&amp;gt; &#39;5&#39;,&#39;level&#39; =&amp;gt; 3,),
    5 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;5&#39;,&#39;pid&#39; =&amp;gt; &#39;2&#39;,&#39;name&#39; =&amp;gt; &#39;欧冠&#39;,&#39;list_order&#39; =&amp;gt; &#39;2&#39;,&#39;level&#39; =&amp;gt; 3,),
    11 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;11&#39;,&#39;pid&#39; =&amp;gt; &#39;5&#39;,&#39;name&#39; =&amp;gt; &#39;皇马&#39;,&#39;list_order&#39; =&amp;gt; &#39;0&#39;,&#39;level&#39; =&amp;gt; 4,)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仔细一想，我们改进之前所写的get_child()成员函数，让其支持level&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
     * 获取对应子栏目
     * @param  int $pid   父id
     * @param  int $level 层级
     * @return array
     */
    function get_child($pid,$level)
    {
        $res_array = array();
        foreach($this-&amp;gt;data as $key =&amp;gt; $val)
        {
            if ($val[&#39;pid&#39;] == $pid)
            {
                $val[&#39;level&#39;] = $level;
                $res_array[$key] = $val;
            }
        }
        return $res_array;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个成员函数写好了，我们可以做最后的事情了。但是，慢着，我们还需要增加一个函数，可以网数组中随意插入一段数组。&lt;br /&gt;
等等，这个貌似已经说过了。&lt;br /&gt;
哈哈，大家发现了吗，&lt;a href=&#34;http://www.yuzhan.me/2014/01/09/php-数组中插入元素/&#34;&gt;php 数组中插入元素&lt;/a&gt;这篇文章，我们直接就已经说过了。此处，我们稍加改进，把函数直接拿过来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 往数组中插入元素
 * @param  mix $value 要插入的值
 * @param  key $key   mix 插入元素的位置
 * @param  array $array 源数组
 * @return array        新数组
 */
function insert_array($value,$key,$array)
{
    //新建数组，用户返回
    $return_array = array();
    foreach($array as $k =&amp;gt; $v)
    {
        //保持原有数组
        $return_array[$k] = $v;
        //当插入位置与值相等，此时，讲元素插入数组
        if ($key == $k)
        {
            //如果为数组，则循环添加
            if(is_array($value))
            {
                foreach($value as $sk =&amp;gt; $sv)
                    $return_array[$sk] = $sv;
            }
            else//非数组，则单一添加
                $return_array[] = $value;
        }
    }
    return $return_array;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了上面的工具，我们可以构想如下代码了，这里我先贴出来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
     * 获取栏目下所有后代栏目
     * @param  int $id 栏目id
     * @return array
     */
    function get_array($id)
    {
        static $level = 1;
        $res = $this-&amp;gt;get_child($id,$level);
        if($level == 1)
            $this-&amp;gt;order_data = $res;
        else
            $this-&amp;gt;order_data = insert_array($res,$id,$this-&amp;gt;order_data);
        if (count($res) &amp;gt; 0)
        {
            $level++;
            foreach($res as $key =&amp;gt; $val)
                $this-&amp;gt;get_array($val[&#39;id&#39;]);
            $level--;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一下贴这么多代码，大家可能不理解，那我就一步步跟大家说。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;static $level = 1;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;static用于函数内部的变量，表示静态变量，此变量有一个特点，函数初次执行之，会进行初始化，递归中再次调用，不会对其再初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//获取字栏目
 $res = $this-&amp;gt;et_child($id,$level);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if($level == 1)
            $this-&amp;gt;order_data = $res;
        else
            $this-&amp;gt;order_data = insert_array($res,$id,$this-&amp;gt;order_data);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面程序似乎很难理解。其实，我们仔细观察，觉得，也没有那么复杂。我们发现，层级为一级时(level = 1),直接将结果赋给排序后的数组。当层级不为一级时，将得到的结果，插入相应的父层级之后。画个流程图让大家明白&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/01/无限级分类操作示意图.png&#34; alt=&#34;无限级分类操作示意图&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (count($res) &amp;gt; 0)
        {
            $level++;
            foreach($res as $key =&amp;gt; $val)
                $this-&amp;gt;get_array($val[&#39;id&#39;]);
            $level--;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一段应该是最难理解的（个人认为）.于是我们分几步来分解&lt;br /&gt;
&lt;strong&gt;第一步：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;if (count($res) &amp;gt; 0){}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;判断是否含有子栏目，如果没有，则不做任何操作&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$level++;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由于是操作子栏目，比如，我们的数据中，&lt;strong&gt;世界&lt;/strong&gt;为&lt;strong&gt;level=1&lt;/strong&gt;，&lt;strong&gt;欧洲&lt;/strong&gt;为&lt;strong&gt;level=2&lt;/strong&gt;。我们每往下一级循环的时候，level都会加1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach($res as $key =&amp;gt; $val)
                $this-&amp;gt;get_array($val[&#39;id&#39;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;递归调用，将对应的数组，插入数组中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$level--;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;回归新的层级&lt;br /&gt;
这两句，看不明白不要紧，同样的，我们画个流程图，给大家看看就明白了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/01/无限级分类递归示意图.png&#34; alt=&#34;无限级分类递归示意图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，我们需要注意的是，每次&lt;strong&gt;foreach&lt;/strong&gt;都没执行完，直到它没有子栏目，则会一步步往上递归。&lt;/p&gt;

&lt;p&gt;好了，排序已经完成了，接下来就是输出了。敬请关注无限级分类第三篇吧&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无限级分类研究：（一）初步构想</title>
      <link>http://www.yuzhan.me/post/2014-01-10-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9D%E6%AD%A5%E6%9E%84%E6%83%B3/</link>
      <pubDate>Fri, 10 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://www.yuzhan.me/post/2014-01-10-%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9D%E6%AD%A5%E6%9E%84%E6%83%B3/</guid>
      <description>&lt;p&gt;对于网站来说，无限级分类是必不可少的。因此，从今天开始，我将会给大家说说无限级分类。&lt;/p&gt;

&lt;p&gt;关于无限级分类，实现有很多种看，这里我们也简单的介绍几种，分析每一种的优缺点。这样，大家以后做无限级分类的时候，可以对比着看看。&lt;/p&gt;

&lt;p&gt;第一种：&lt;br /&gt;
我们先建一张表，本着最传统的模式，我们选择，id,pid,name,list_order,具体sql如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE `category_1_copy` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;分类id&#39;,
  `pid` int(10) unsigned NOT NULL COMMENT &#39;分类父id&#39;,
  `name` varchar(30) NOT NULL COMMENT &#39;分类名称&#39;,
  `list_order` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;分类排序，默认为0&#39;,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了方便写程序，我们插入一些数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO `category_1_copy` VALUES (&#39;1&#39;, &#39;0&#39;, &#39;新闻&#39;, &#39;0&#39;);
INSERT INTO `category_1_copy` VALUES (&#39;2&#39;, &#39;1&#39;, &#39;体育新闻&#39;, &#39;0&#39;);
INSERT INTO `category_1_copy` VALUES (&#39;3&#39;, &#39;1&#39;, &#39;社会新闻&#39;, &#39;3&#39;);
INSERT INTO `category_1_copy` VALUES (&#39;4&#39;, &#39;2&#39;, &#39;NBA&#39;, &#39;5&#39;);
INSERT INTO `category_1_copy` VALUES (&#39;5&#39;, &#39;2&#39;, &#39;欧冠&#39;, &#39;2&#39;);
INSERT INTO `category_1_copy` VALUES (&#39;6&#39;, &#39;0&#39;, &#39;世界&#39;, &#39;4&#39;);
INSERT INTO `category_1_copy` VALUES (&#39;7&#39;, &#39;6&#39;, &#39;中东&#39;, &#39;0&#39;);
INSERT INTO `category_1_copy` VALUES (&#39;8&#39;, &#39;6&#39;, &#39;欧洲&#39;, &#39;6&#39;);
INSERT INTO `category_1_copy` VALUES (&#39;9&#39;, &#39;8&#39;, &#39;俄罗斯&#39;, &#39;0&#39;);
INSERT INTO `category_1_copy` VALUES (&#39;10&#39;, &#39;3&#39;, &#39;大楚新闻&#39;, &#39;0&#39;);
INSERT INTO `category_1_copy` VALUES (&#39;11&#39;, &#39;5&#39;, &#39;皇马&#39;, &#39;0&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是我们可以看到表中的数据，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/01/felei-300x206.png&#34; alt=&#34;无限极分类数据库&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我们采用类的形式来解决，&lt;/p&gt;

&lt;p&gt;我们规划一下，如何写这个类。首先，必须要有一个属性存数据，我们记作 &lt;strong&gt;$data&lt;/strong&gt;,然后我们正确分级后的数据,我们记作&lt;strong&gt;$list_data&lt;/strong&gt;,于是我们写下程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class category_1{
    protected $data=array(),$order_data=array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们要取得所有数据，放入&lt;strong&gt;$data&lt;/strong&gt;中，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class category_1
{
    protected $db,$data=array(),$order_data=array();

    function __construct()
    {
        $this-&amp;gt;db = new mysqli(&amp;quot;localhost&amp;quot;,&amp;quot;***&amp;quot;,&amp;quot;***&amp;quot;,&amp;quot;fenlei&amp;quot;);
        $this-&amp;gt;data();
    }

    /**
     * 获取数据
     * @return void
     */
    function data()
    {
        $sql = &amp;quot;select * from category_1_copy&amp;quot;;
        $res = $this-&amp;gt;db-&amp;gt;query($sql);
        while($row = $res-&amp;gt;fetch_assoc())
        {
            //这里存入每个类别的id，有助于之后的程序
            $this-&amp;gt;data[$row[&#39;id&#39;]] = $row;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，为这个类，添加一个显示的入口&lt;strong&gt;$show&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function show(){ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，我们开始给分类做层级排序，当然,我们最后希望的到的结果，可能如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/01/无限极效果.png&#34; alt=&#34;无限极效果&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果把这个显示问题提上来一步，我们会发现结构可能如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;array (
    6 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;6&#39;, &#39;pid&#39; =&amp;gt; &#39;0&#39;,  &#39;name&#39; =&amp;gt; &#39;世界&#39;, &#39;list_order&#39; =&amp;gt; &#39;4&#39;),
    8 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;8&#39;, &#39;pid&#39; =&amp;gt; &#39;6&#39;,  &#39;name&#39; =&amp;gt; &#39;欧洲&#39;, &#39;list_order&#39; =&amp;gt; &#39;6&#39;),
    9 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;9&#39;, &#39;pid&#39; =&amp;gt; &#39;8&#39;,  &#39;name&#39; =&amp;gt; &#39;俄罗斯&#39;, &#39;list_order&#39; =&amp;gt; &#39;0&#39;),
    7 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;7&#39;, &#39;pid&#39; =&amp;gt; &#39;6&#39;,  &#39;name&#39; =&amp;gt; &#39;中东&#39;, &#39;list_order&#39; =&amp;gt; &#39;0&#39;),
    1 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;1&#39;, &#39;pid&#39; =&amp;gt; &#39;0&#39;,  &#39;name&#39; =&amp;gt; &#39;新闻&#39;, &#39;list_order&#39; =&amp;gt; &#39;0&#39;),
    3 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;3&#39;, &#39;pid&#39; =&amp;gt; &#39;1&#39;,  &#39;name&#39; =&amp;gt; &#39;社会新闻&#39;, &#39;list_order&#39; =&amp;gt; &#39;3&#39;),
    10 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;10&#39;, &#39;pid&#39; =&amp;gt; &#39;3&#39;,  &#39;name&#39; =&amp;gt; &#39;大楚新闻&#39;, &#39;list_order&#39; =&amp;gt; &#39;0&#39;),
    2 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;2&#39;, &#39;pid&#39; =&amp;gt; &#39;1&#39;,  &#39;name&#39; =&amp;gt; &#39;体育新闻&#39;, &#39;list_order&#39; =&amp;gt; &#39;0&#39;),
    4 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;4&#39;, &#39;pid&#39; =&amp;gt; &#39;2&#39;,  &#39;name&#39; =&amp;gt; &#39;NBA&#39;, &#39;list_order&#39; =&amp;gt; &#39;5&#39;),
    5 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;5&#39;, &#39;pid&#39; =&amp;gt; &#39;2&#39;,  &#39;name&#39; =&amp;gt; &#39;欧冠&#39;, &#39;list_order&#39; =&amp;gt; &#39;2&#39;),
    11 =&amp;gt; array (&#39;id&#39; =&amp;gt; &#39;11&#39;, &#39;pid&#39; =&amp;gt; &#39;5&#39;,  &#39;name&#39; =&amp;gt; &#39;皇马&#39;, &#39;list_order&#39; =&amp;gt; &#39;0&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如何实现这一部，我们可以构想一下。&lt;/p&gt;

&lt;p&gt;首先我们可以把最一级分类取出来，排成一列，然后把二级分类取出来，插入相应的一级分类之后，接着，取出第三级分类，然后放入对应的二级分类之后，以此类推。&lt;/p&gt;

&lt;p&gt;示意图如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/01/无限级分类流程示意图.png&#34; alt=&#34;无限级分类流程示意图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看了示意图，大家是否明白一些了？&lt;br /&gt;
于是我们开始写程序，仔细观察示意图，我们发现，每次排序，我们需要取出下级数据，于是我们可以写成一个成员函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
     * 获取对应子栏目
     * @param  int $pid   父id
     * @return array
     */
    function get_child($pid)
    {
        $res_array = array();
        foreach($this-&amp;gt;data as $key =&amp;gt; $val)
        {
            if ($val[&#39;pid&#39;] == $pid)
                $res_array[$key] = $val;
        }
        return $res_array;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今天就到这里，明天就后面的问题进行探讨&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>php 数组中插入元素</title>
      <link>http://www.yuzhan.me/post/2014-01-09-php-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8F%92%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 09 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://www.yuzhan.me/post/2014-01-09-php-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8F%92%E5%85%83%E7%B4%A0/</guid>
      <description>&lt;p&gt;因为，手头上有些事，可能需要这个需求。乍一看，我们会直接想到往数组中插入某个值。对于&lt;strong&gt;偏移量和键值相等的数组&lt;/strong&gt;来说是比较简单的事。&lt;/p&gt;

&lt;p&gt;比如，从开头插入，我们可以选择&lt;/p&gt;

&lt;p&gt;&lt;code&gt;array_unshift()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;,从末尾插入，我们可以选择&lt;/p&gt;

&lt;p&gt;&lt;code&gt;array_push&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;,如果只是从数组当中插入呢，php也提供给我们很好的函数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;array_splice()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;关于&lt;/p&gt;

&lt;p&gt;&lt;code&gt;array_splice&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个函数，有必要说一下，这个函数原本的功能适用于数组替换。&lt;br /&gt;
&lt;strong&gt;array array_splice ( array &amp;amp;$input , int $offset [, int $length [, array $ replacement ]] )&lt;/strong&gt;&lt;br /&gt;
其中&lt;br /&gt;
第一个参数 &amp;amp;$input 为要传入的数组，注意，这里用了&amp;amp;符号，我们知道可以对原数组直接操作。&lt;br /&gt;
第二个参数 $offset 其实位置，从哪里开始替换，也就是数组下标&lt;br /&gt;
第三个参数 $length 替换长度，默认不填则表示道数组结尾部分，0表示直接该下标后追加，其他后面元素向后偏移一个单位&lt;br /&gt;
第四个参数 $replacement 替换元素，此处不填，则表示删除&lt;br /&gt;
比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$input = array(&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;yellow&amp;quot;);
array_splice($input, 2, 1, &amp;quot;demo&amp;quot;);
//print_r($input)
/*Array
(
    [0] =&amp;amp;gt; red
    [1] =&amp;amp;gt; green
    [2] =&amp;amp;gt; demo
    [3] =&amp;amp;gt; yellow
)*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据上面所说的，我们可以很简单的模拟,就可以实现往数组中插入元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$input = array(&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;yellow&amp;quot;);
array_splice($input, 3, 0, &amp;quot;purple&amp;quot;);

// print_r($input);
/*Array
(
    [0] =&amp;amp;gt; red
    [1] =&amp;amp;gt; green
    [2] =&amp;amp;gt; blue
    [3] =&amp;amp;gt; purple
    [4] =&amp;amp;gt; yellow
)*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面讲了那么多，我们思考一下，，&lt;strong&gt;偏移量和数组不相等的数组&lt;/strong&gt;如何添加,思考之后，得出如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 往数组中插入元素
 * @param  mix $value 要插入的值
 * @param  key $key   mix 插入元素的位置
 * @param  array $array 源数组
 * @return array        新数组
 */
function insert_array($value,$key,$array)
{
    //新建数组，用户返回
    $return_array = array();
    foreach($array as $k =&amp;amp;gt; $v)
    {
        //保持原有数组
        $return_array[$k] = $v;
        //当插入位置与值相等，此时，讲元素插入数组
        if ($key == $k)
        {
            //如果为数组，则循环添加
            if(is_array($value))
            {
                foreach($value as $sk =&amp;amp;gt; $sv)
                    $return_array[$sk] = $sv;
            }
            else//非数组，则单一添加
                $return_array[] = $value;
        }
    }
    return $return_array;
}

//做个测试
$array = array(&amp;quot;demo&amp;quot;=&amp;amp;gt;&amp;quot;a&amp;quot;,&amp;quot;de&amp;quot;=&amp;amp;gt;&amp;quot;b&amp;quot;,&amp;quot;ke&amp;quot;=&amp;amp;gt;&amp;quot;c&amp;quot;);

//在demo下标后插入new
$array = insert_array(&amp;quot;new&amp;quot;,&amp;quot;demo&amp;quot;,$array);

//print_r($array);
/*Array
(
    [demo] =&amp;amp;gt; a
    [0] =&amp;amp;gt; new
    [de] =&amp;amp;gt; b
    [ke] =&amp;amp;gt; c
)*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是全部内容，如果有正确的地方，还望指正&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>sphinx优化用户标签匹配</title>
      <link>http://www.yuzhan.me/post/2014-01-07-%E5%85%B3%E4%BA%8E%E7%94%A8%E6%88%B7%E6%A0%87%E7%AD%BE%E5%8C%B9%E9%85%8D%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 07 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://www.yuzhan.me/post/2014-01-07-%E5%85%B3%E4%BA%8E%E7%94%A8%E6%88%B7%E6%A0%87%E7%AD%BE%E5%8C%B9%E9%85%8D%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;p&gt;前段时间，正好忙于搜索的工作。数据库也不大，总共下来估计也才10w左右的数据。但考虑到之后的扩展，就选用了sphinx。对于sphinx的优点，相信用过的都知道，这里就不多费口舌。&lt;/p&gt;

&lt;p&gt;后来，项目版本更新之后，原计划的搜索需要做一次整改。调整如下：&lt;/p&gt;

&lt;p&gt;每个登录的用户，前台有个公共标签，这个作为搜索条件(sphinx解决，不多解释)。而且，每个用户还有个隐性标签，供后台使用。当用户搜索关键词的时候就需要按照关键词的匹配度来进行排序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/01/QQ截图20140107134143.png&#34; alt=&#34;示例图1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上图，用户自身有三个隐性标签，经过搜索之后，出现四条结果。按标签匹配度来算应该结果一在最前面，结果四在最后面。既然如此，我们该如何解决这个问题呢？&lt;/p&gt;

&lt;p&gt;要解决这个问题，我们先得走个过程。&lt;/p&gt;

&lt;p&gt;我们知道，匹配度的高低，得按照标签相同的对数来计算。而之前所做的隐性标签，只是简简单单的以id和人来挂钩。根据此类结构我们能够想到的方法，可以按照如下流程来走&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$tag1 = &amp;quot;标签一&amp;quot;;
$tag2 = &amp;quot;标签二&amp;quot;;
$tag3 = &amp;quot;标签三&amp;quot;;

//第一步，取出用户标签
$user_tags = array($tag1,$tag2,$tag3);

//第二步，取出搜索结果标签
$result_tags = array(
    &amp;quot;res1&amp;quot; =&amp;amp;gt; array($tag1,$tag2,$tag3),
    &amp;quot;res2&amp;quot; =&amp;amp;gt; array($tag1,$tag2),
    &amp;quot;res3&amp;quot; =&amp;amp;gt; array($tag2,$tag3),
    &amp;quot;res4&amp;quot; =&amp;amp;gt; array($tag3)
);

//第三步，用户标签做匹配
$result_weight = array();
foreach ($result_tags as $key =&amp;amp;gt; $val)
    $result_weight[$key] = count(array_intersect($user_tags,$val));

/*输出数组
print_r($result_weight);
Array
(
    [res1] =&amp;amp;gt; 3
    [res2] =&amp;amp;gt; 2
    [res3] =&amp;amp;gt; 2
    [res4] =&amp;amp;gt; 1
)
*/

//根据上述排序，我们就可以得到正确的顺序，加以转换，就可以正确输出
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上程序似乎解决了问题，但实际上并非如此。我们仔细观察会发现，数据量大了之后，原先存入mysql的tags，在读取上造成了很大的开销。针对这个，我们可以选择缓存，如redis或memcache都是不错的选择。&lt;/p&gt;

&lt;p&gt;那么，是否可以说大功告成了？&lt;/p&gt;

&lt;p&gt;我们的答案是没有，其实程序第三步做标签匹配的时候，存在大量的计算，再10w条数据下，程序要经过10w次计算，这对于性能的消耗，可想而知。因此，此方法是行不通的。&lt;/p&gt;

&lt;p&gt;既然行不通，我们有没有其他方法？&lt;/p&gt;

&lt;p&gt;经过思考，我们找到一个新的方法。把这个过程交给sphinx去做,下面就慢慢道来：&lt;/p&gt;

&lt;p&gt;我们知道，&lt;code&gt;sphinx(coreseek)&lt;/code&gt;,对于文字匹配，会计算权重。匹配的项越多，权重越高。因此，完全可以用来做权重。&lt;/p&gt;

&lt;p&gt;慢着，等等，你不可能让sphinx搜索tags的id，这个重复的概率太大了，会导致搜索不准确。&lt;/p&gt;

&lt;p&gt;所以，我们加上一个字段，给tag做了冗余，附加到用户表上，整个流程如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.yuzhan.me/public/img/images/2014/01/QQ截图20140107143046.png&#34; alt=&#34;流程图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们把匹配的工作交给sphinx，高效而且精准。将返回来的值进行排序，就可以得到正确结果。&lt;/p&gt;

&lt;p&gt;当然，实际工作中，可能没有我说的那么简单，还有很多步奏要处理，不过，大概的思路就是如此。&lt;/p&gt;

&lt;p&gt;希望此文对大家有帮助。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>计算两个数组差集方法的优化</title>
      <link>http://www.yuzhan.me/post/2014-01-07-%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%B7%AE%E9%9B%86%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Tue, 07 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://www.yuzhan.me/post/2014-01-07-%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%B7%AE%E9%9B%86%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>&lt;p&gt;之前做一个项目，其中涉及到计算两个数组之间的差集。于是毫不犹豫的情况下选择了array_diff。&lt;/p&gt;

&lt;p&gt;事隔多天之后，再回头来看，觉得貌似不太满意，重新做了个测试。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先构建数组&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$array = array();
$chars=&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890+-_@#$%&amp;amp;^*()!&#39;;

for($i=0;$i&amp;amp;lt;100000;$i++)
{
    $len = rand(1,50);
    $str = substr(str_shuffle($chars),0,$len).rand(1,90000);
    array_push($array,$str);
}

$filename = &amp;quot;one.php&amp;quot;;
$content = &amp;quot;&amp;amp;lt;?php return &amp;quot;.var_export($array,true).&amp;quot;?&amp;amp;gt;&amp;quot;;
$handle = fopen($filename,&amp;quot;w&amp;quot;);
fwrite($handle,$content);
fclose($handle);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;讲数组存入两个文件，one.php,two.php&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;计算两个数组的差集&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法一&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//求两个数组之间的差集
$arr1 = include_once(&amp;quot;one.php&amp;quot;);
$arr2 = include_once(&amp;quot;two.php&amp;quot;);

$start_time = microtime();

$one = array_diff($arr1,$arr2);
$end_time = microtime();

echo count($one).&amp;quot;&amp;amp;lt;br/&amp;amp;gt;&amp;quot;;
var_dump($end_time-$start_time);
//输出0,float(0.25),此处取平均值

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//求两个数组之间的差集
$arr1 = include_once(&amp;quot;one.php&amp;quot;);
$arr2 = include_once(&amp;quot;two.php&amp;quot;);
$start_time = microtime();
$temp = array_flip($arr2);
foreach($arr1 as $key =&amp;amp;gt; $val)
  if(isset($temp[$val]))
    unset($arr1[$key]);

$end_time = microtime();

echo count($arr1).&amp;quot;&amp;amp;lt;br/&amp;amp;gt;&amp;quot;;
var_dump($end_time-$start_time);

//输出0,float(0.078) ,此处取平均值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的实验得知，方法二的时间较为缩短，于是上网搜了一下资料得知：&lt;br /&gt;
&lt;strong&gt;键是进行 HASH 组织的，查找很快；&lt;/strong&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;而 Value 只是由 Key 组织存放，本身没有索引，每次查找都是遍历。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当然，这个一时无聊所做的测试，对于网站而言，这点速度的优化算不上什么。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>